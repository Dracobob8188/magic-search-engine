#!/usr/bin/env ruby

require_relative "../search-engine/lib/card_database"
require "memoist"

class ExportFormatter
  def initialize(exporter)
    @db = exporter.db
    @uuids = exporter.uuids
  end

  def uuid_for(set_code, number)
    @uuids.fetch(set_code).fetch(number)
  end

  def integerize_evs(ev)
    # Normalize rationals to weights
    lcm = ev.values.map(&:denominator).inject(&:lcm)
    ev.map{|k,v|
      vv = v*lcm
      raise unless vv.to_i == vv
      [k, vv.to_i]
    }.to_h
  end

  def serialize_sheets(sheets)
    sheets.map{|sheet, id|
      [id, serialize_sheet(sheet)]
    }.to_h
  end

  def flatten_pack(pack)
    result = if pack.is_a?(WeightedPack)
      pack.flatten_weighted_pack
    else
      WeightedPack.new(pack => 1)
    end
    result.set = pack.set
    result.code = pack.code
    result.name = pack.name
    result
  end

  def extract_sheets(pack)
    sheets = pack.packs.keys.map(&:sheets).flat_map(&:keys)
    sheets.map{|s|
      [s, @db.pack_factory.sheet_cache.invert[s].join("_")]
    }.to_h
  end

  def serialize_subpack(pack, weight, sheets)
    {
      sheets: pack.sheets.map{|s,c| [sheets[s], c]}.to_h,
      weight: weight,
    }
  end

  def call(path)
    path.write JSON.pretty_generate(data)
  end
end

class ExportFormatterBasic < ExportFormatter
  def serialize_sheet(sheet)
    ev = integerize_evs sheet.probabilities

    cards = ev.sort_by{|e,w| [e.set_code, e.number, e.foil ? 0 : 1]}.map do |e,w|
      name = "#{e.set_code}:#{e.number}"
      name = "#{name}:foil" if e.foil
      [name, w]
    end.sort.to_h

    {
      partner: sheet.is_a?(PartnerCardSheet) ? true : nil,
      balance_colors: sheet.is_a?(ColorBalancedCardSheet) ? true : nil,
      total_weight: cards.values.sum,
      cards: cards,
    }.compact
  end

  def data
    result = []
    @db.supported_booster_types.each do |booster_code, booster|
      booster = flatten_pack(booster)
      sheets = extract_sheets(booster)
      result << {
        name: booster.name,
        code: booster.code,
        set_code: booster.set_code,
        set_name: booster.set_name,
        boosters: booster.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets),
      }
    end
    result
  end
end

class ExportFormatterExtended < ExportFormatter
  def serialize_sheet(sheet)
    ev = integerize_evs sheet.probabilities

    cards = ev.sort_by{|e,w| [e.set_code, e.number, e.foil ? 0 : 1]}.map do |e,w|
      {
        set: e.set_code,
        number: e.number,
        weight: w,
        foil: e.foil,
        uuid: uuid_for(e.set_code, e.number)
      }
    end.sort_by{|x| [x[:set_code], x[:number].to_i, x[:number]] }

    {
      partner: sheet.is_a?(PartnerCardSheet) ? true : nil,
      balance_colors: sheet.is_a?(ColorBalancedCardSheet) ? true : nil,
      total_weight: cards.map{|x| x[:weight]}.sum,
      cards: cards,
    }.compact
  end

  def data
    result = []
    @db.supported_booster_types.each do |booster_code, booster|
      booster = flatten_pack(booster)
      sheets = extract_sheets(booster)
      result << {
        name: booster.name,
        code: booster.code,
        set_code: booster.set_code,
        set_name: booster.set_name,
        boosters: booster.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets),
      }
    end
    result
  end
end

class ExportFormatterExperimental < ExportFormatterExtended
  def data
    result = []
    @db.supported_booster_types.each do |booster_code, booster|
      booster = flatten_pack(booster)
      sheets = extract_sheets(booster)
      result << {
        name: booster.name,
        code: booster.code.upcase,
        setCode: booster.set_code.upcase,
        setName: booster.set_name,
        boosters: booster.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets),
      }
    end
    result
  end
end

class ExportSealedData
  include Memoist
  attr_reader :db, :uuids

  def initialize(output_folder)
    @db = CardDatabase.load
    @output_folder = Pathname(output_folder)
    load_uuids
  end

  def uuid_file_path
    Pathname(__dir__) + "../index/uuids.txt"
  end

  def load_uuids
    @uuids = {}
    uuid_file_path.each_line do |line|
      s, n, u, _ = line.chomp.split("\t")
      @uuids[s] ||= {}
      raise if @uuids[s][n]
      @uuids[s][n] = u
    end
  end

  def basic_output_path
    @output_folder + "sealed_basic_data.json"
  end

  def extended_output_path
    @output_folder + "sealed_extended_data.json"
  end

  def experimental_output_path
    @output_folder + "experimental_export_for_mtgjson.json"
  end

  def call
    ExportFormatterBasic.new(self).call(basic_output_path)
    ExportFormatterExtended.new(self).call(extended_output_path)
    ExportFormatterExperimental.new(self).call(experimental_output_path)
  end
end

output_folder = ARGV[0] || "."
ExportSealedData.new(output_folder).call
